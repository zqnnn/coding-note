//
// Created by zqn on 2019/5/30.
//
#include <vector>
#include <iostream>
#include <limits.h>
using namespace std;
//买卖股票的最佳时机二
//题目描述
//给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
//设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
//注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。


//示例 1:
//
//输入: [7,1,5,3,6,4]
//输出: 7
//解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
//随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
//
//示例 2:
//
//输入: [1,2,3,4,5]
//输出: 4
//解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
//注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
//因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
//
//示例 3:
//
//输入: [7,6,4,3,1]
//输出: 0
//解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
//---------------------

//思路：
//由题目可知，可多次重复购买，所以我们本质上要找的是短期最佳，一笔一笔交易找。例如：
//[1,6,7] 这种情况下，最大化的利润为7-1，但我们可以理解为第一日买第二日卖，第二日买第三日卖

//遍历每日的价格，如果下一期的价格大于上一期，那么更新result，此为前一阶段的最大化。

//或许有人会问：会不会后续交易的最大值还是在最初那一笔交易前提下产生的呢？我也有这种疑问，
// 我们来看一下，例如：[1,3,6,5,7] 这种情况，有人会觉得可能在第一天买入第五天卖出可能利润最大，但不会出现这种情况。
// 假设第五天的值为m,第3天这种情况下值为k
// k>m 不用考虑，利润最大化在第三天卖出
//k>= m 此情况下，第一天买入，第三天卖出后。可在第四天买入第五天卖出，此时利润才是最大的。所以更新规则是正确的。

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int max = 0, size = prices.size();
        for(int i = 0; i < size-1; i++){
            if(prices[i] < prices[i+1]){
                max += prices[i+1] - prices[i];
            }
        }
        return max;
    }
};

int main()
{
    vector<int> vec = {1,2,3,4,5};
//    int temp=0;
//    while(cin >> temp) //如果不确定输入数字个数，可以用这种方式
//    {
//        vec.push_back(temp); //填充数据
//    }
    Solution s;
    cout << s.maxProfit(vec);
    return 0;
}